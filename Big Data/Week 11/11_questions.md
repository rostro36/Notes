# Big Data Week 11

## Questions
- What is the benefit of data independence?
	- The logical language (SQL) works on many different physical implementations (Postgres, Spark, Hive).
- What is a limitation of data independence?
	- It needs data homogeneity or Spark enforces data homogeneity in a non-optimal way (convert an array to a string etc.).
- Why was JSONiq invented?
	- It can query heterogeneous, denormalized (even more than once, what still is okay for Spark) data nicely compared to SQL.
- What makes a good query language?
	- Declarative: What? (and not how) also enables data independence
	- Functional: The language expressions act like mathematical functions that operate on an instance of a model.
	- Set-based: Act on one or a set of instances and output a set of instances.
- What is the language ecosystem for trees?
	- There is none, but it is again XML vs JSON and different languages for different operations:
		- Navigation: XPath vs JSONPath
		- Transform. XSLT vs JSONT
		- XQuery: XQuery vs JSONiq (and more)
		- Update scripts: XQuery Update Facility vs JSONiq
- What is the JSONiq data model?
	- Ordered sequences of items
- What are the properties of sequences?
	- The sequence is ordered and flat, without a hierarchy.
- What are the properties of the items that a sequence holds?
	- Items can be denormalised and heterogeneous.
- What are the items of JSOniq?
	- atomic
	- array (enable hierarchy)
	- objects (enable hierarchy)
	- functions
- How does JSONiq open a json file?
	- json-doc("myfile.json")
- What is the navigation for JSONiq?
	- "." for objects
	- "[q]" for arrays (if q is none, then it is the same as explode and q=[number] for an index)
- How can filtering be done in JSONiq?
	- [$$.code="CH"] responds with the indices where the code is "CH"
- What does $ mean in JSONiq?
	- # $ is the context item, that enables local variables *****************************
	- $$ means each object, that would match the condition
- What are the literals/atomics of JSON?
	- Strings
	- Numbers
	- Booleans
	- null
- How can you escape in JSONiq?
	- With \
- What do we do for other datatypes e.g. dates?
	- There are implemented functions that take strings as input and return some other datatype.
- How can you build a sequence?
	- With "," e.g. *(1,2,3,4,5,6,7,8,9,10)* 
	- With "to" e.g. *1 to 10*
- What is the difference between a sequence and an array?
	- A sequence, which is on top, can scale into the millions, an array, that sits lower, does not scale as well.
- What is the difference between a sequence of (1) and the array [1]?
	- The sequence is equal to 1, while the array encodes a level of hierarchy.
- What are some basic operations?
	- integer arithmetic
		- Empty sequence, where "()+1"=()
		- typed, not allowed for nested objects
	- String operations:
		- concat
		- string-join
		- take sub strings
		- length of string
	- Evaluation (eq, le)
		- General comparisons (=,< etc.)
			- if one item of the sequence matches, the whole sequence returns one true, this holds on both sides
	- Logics (and, or, not) including non boolean like "if"
- What is the default behaviour of operations with the empty sequence?
	- an operation on an empty sequence returns the empty sequence
- When using "if", what is the default behaviour of non boolean values?
	- "0" and empty means *False*, complex datatypes give errors, else *True*.
- Can I add an integer and a string?
	- No, JSONiq is typed, the only "semi-typed" object is the empty set.
- How is JSONiq evaluated?
	- JSONiq is a functional language and as such, there is no evaluation flow, as this is done in a level below the language, but the default is lazy.
- What is meant by composability?
	- An expression (e.g. 1+2) can be part of any other expression (e.g. "from 1 to 1+2".
- What does FLOWR stand for?
	- For
	- Let
	- Order by
	- Where
	- Return
	- (Group by)
- What is the translation of FLOWR to SQL?
	- SELECT.. FROM.. WHERE ..
- What is the structure of a FLOWR expression?
	- Start with *let* or *for*.
	- Use *order*, *group*, *where*.
	- End with *return*.
- What is a difference when grouping between FLOWR and SQL?
	- In SQL, after grouping, the rows are not available any more, only the groups, whereas with FLOWR, each row of the group still is available.
- Checking for type is optional, but can be done with *is instance of*, *castable*, *as*
- *allowing empty* enables outer joins
- What is the flow from a JSONiq query to it's execution?
	- query -parsing-> abstract syntax tree -translation-> expression Tree -optimization-> (another) expression tree -code generation-> iterator tree -iterate&materialize-> execution
- What is materialize?
	- The iteration of the iterator tree, but also take the data with you to memory (this often can be streamed, if the expression allows it).